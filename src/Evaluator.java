import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * This class contains methods to compute the stats for evaluation.
 * 
 * @author Uwe Boltz
 *
 */
public class Evaluator {
	

	private BufferedWriter outputWriter;
	

	
	public Evaluator(String outputFile){
		
		try {				
			FileOutputStream output = new FileOutputStream(outputFile);
			OutputStreamWriter streamWriter = new OutputStreamWriter(output, "UTF-8");

			this.outputWriter = new BufferedWriter(streamWriter);
		}
		
		catch(IOException e) {
			e.printStackTrace();
		}

	}
	
	
	
	/**
	 * Computes precision, recall and f-score for each tag and outputs it.
	 */
	public void printTagResults(List<TaggedToken> taggedTokens){
		
		int truePositives;
		int falsePositives;
		int falseNegatives;		
		int trueNegatives;	
		float precision;
		float recall;
		float fScore;
		
		int numberOfTokens = taggedTokens.size();
		
		HashMap<String, TagStats> tagStats = getTagStats(taggedTokens);
		HashSet<String> tags = getGeneratedTags(taggedTokens);
		
		for(Map.Entry<String, TagStats> tag: tagStats.entrySet()) {
			//TODO this if clause should be optional depending on parameters
			if(tags.contains(tag.getKey())) {
				truePositives = tag.getValue().truePositives;
				falsePositives = tag.getValue().falsePositives;
				falseNegatives = tag.getValue().falseNegatives;

				trueNegatives = numberOfTokens 
				- truePositives
				- falsePositives
				- falseNegatives;

				//beware the divide by zero
				if(truePositives + falsePositives != 0) {
					precision = (float) truePositives / (truePositives + falsePositives);
				}
				else {
					precision = 0;
				}
				if(truePositives + falseNegatives != 0) {
					recall = (float) truePositives / (truePositives + falseNegatives);
				}
				else {
					recall = 0;
				}
				if(precision + recall != 0) {
					fScore = precision * recall / (2 * (precision + recall));
				}
				else {
					fScore = 0;
				}

				println();
				println(tag.getKey());
				println(
						" Overall: " + tag.getValue().inTestData
						+ "    true pos: " + truePositives
						+ "    false pos: " + falsePositives
						+ "    true neg: " + trueNegatives 
						+ "    false neg: " + falseNegatives
						+ "    prec: " + precision
						+ "    rec: " + recall
						+ "    f1: " + fScore);
				println();
				println();
			}
		}

	}

	public void printOverallResults(List<TaggedToken> taggedTokens){
		
		int numberOfTokens = taggedTokens.size();
		int numberOfCorrectTags = 0;
		
		for(TaggedToken token : taggedTokens){
			if(token.correctTag())
				numberOfCorrectTags++;
			
		}
		
		println("Tokens: " + numberOfTokens
				+ "   Correct: " + numberOfCorrectTags
				+ " " + ((float) numberOfCorrectTags / ( numberOfTokens)* 100) + "%");
		
		int falseNegatives = 0;
		int falsePositives = 0;
		int truePositives = 0;
		int trueNegatives = 0;
		int inTestData = 0;
		float precision;
		float recall;
		float fScore;
		HashMap<String, TagStats> tagStats = getTagStats(taggedTokens);
		
		for(String tag : getGeneratedTags(taggedTokens)) {
			
			if(!tag.equals("unknown")) {
				TagStats stats = tagStats.get(tag);
				falseNegatives += stats.falseNegatives;
				falsePositives += stats.falsePositives;
				truePositives += stats.truePositives;
				inTestData += stats.inTestData;
			}
		}
		
		for(TaggedToken token : taggedTokens){
			if(token.generatedTag.equals("unknown")) {
				trueNegatives++;
			}
		}
		
		//beware the divide by zero
		if(truePositives + falsePositives != 0) {
			precision = (float) truePositives / (truePositives + falsePositives);
		}
		else {
			precision = 0;
		}
		if(truePositives + falseNegatives != 0) {
			recall = (float) truePositives / (truePositives + falseNegatives);
		}
		else {
			recall = 0;
		}
		if(precision + recall != 0) {
			fScore = precision * recall / (2 * (precision + recall));
		}
		else {
			fScore = 0;
		}
		
		println();
		println("For tags generated by the tagger overall:");
		println("true pos: " + truePositives + "  out of a possible " + inTestData);
		println("false pos: " + falsePositives);
		println("true neg: " + trueNegatives);
		println("false neg: " + falseNegatives);
		println();
		println("Precision: " + precision);
		println("Recall: " + recall);
		println("F-Score: " + fScore);
	}
	
	
	
	
	
	
	
	private HashMap<String, TagStats> getTagStats(List<TaggedToken> taggedTokens){
		
		HashMap<String, TagStats> tagStats = new LinkedHashMap<String, TagStats>();
		HashSet<String> tags = getAllTags(taggedTokens);
		
		
		for(String tag : tags) {
			
			
			TagStats stats = new TagStats();
			
			for(TaggedToken token : taggedTokens) {
				
				if(token.generatedTag.equals(tag)){
					
					
					if(token.correctTag()) {
						stats.truePositives++;
						stats.inTestData++;
					}
					else {
						stats.falsePositives++;
					}
					
				}
				else if(token.testDataTag.equals(tag)) {
					
					stats.inTestData++;
					
					if(!token.correctTag()) {
						stats.falseNegatives++;
					}

				}
			
			}
			
			stats.trueNegatives = stats.inTestData
									- stats.falseNegatives
									- stats.falsePositives
									- stats.truePositives;
			
			tagStats.put(tag, stats);		
		}
		
		return tagStats;
	}
	
	
	private HashSet<String> getGeneratedTags(List<TaggedToken> taggedTokens){
		HashSet<String> tags = new HashSet<String>();
		
		for(TaggedToken token : taggedTokens){
			tags.add(token.generatedTag);
		}
		
		return tags;
	}
	
	private HashSet<String> getTestDataTags(List<TaggedToken> taggedTokens){
		HashSet<String> tags = new HashSet<String>();
		
		for(TaggedToken token : taggedTokens){
			tags.add(token.testDataTag);
		}
		
		return tags;
	}
	
	private HashSet<String> getAllTags(List<TaggedToken> taggedTokens){
		HashSet<String> tags = new HashSet<String>();
		
		for(TaggedToken token : taggedTokens){
			tags.add(token.generatedTag);
			tags.add(token.testDataTag);
		}
		
		return tags;
	}
	
	public void println() {	
		try {
			System.out.println();
			outputWriter.newLine();
			outputWriter.flush();
		} catch (IOException e) {
			
			e.printStackTrace();		
		}
		
	}
	
	public void println(String message){
		try {
			System.out.println(message);
			outputWriter.write(message);
			outputWriter.newLine();
			outputWriter.flush();
		} catch(IOException e) {

			e.printStackTrace();
		}
		
	}
	
	//TODO confusion matrix, word counts, tag counts, stats per tag, ambiguous words
	// evaluate per rule?
	
	
	
	

}
