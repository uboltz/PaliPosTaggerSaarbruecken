import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

/**
 * This class contains methods to compute the stats for evaluation.
 * 
 * @author Uwe Boltz
 *
 */
public class Evaluator {
	

	private OutputWriter output;
	private OutputWriter debug;
	

	
	public Evaluator(OutputWriter output, OutputWriter debug){
		
		this.output = output;
		this.debug = debug;

	}
	
	
	
	/**
	 * Computes precision, recall and f-score for each tag and outputs it.
	 */
	public void printTagResults(List<TaggedToken> taggedTokens){
		
		int truePositives;
		int falsePositives;
		int falseNegatives;		
		int trueNegatives;	
		float precision;
		float recall;
		float fScore;
		
		int numberOfTokens = taggedTokens.size();
		
		HashMap<String, TagStats> tagStats = getTagStats(taggedTokens);
		HashSet<String> tags = getGeneratedTags(taggedTokens);
		
		for(Map.Entry<String, TagStats> tag: tagStats.entrySet()) {
			//TODO this if clause should be optional depending on parameters
			if(tags.contains(tag.getKey())) {
				truePositives = tag.getValue().truePositives;
				falsePositives = tag.getValue().falsePositives;
				falseNegatives = tag.getValue().falseNegatives;

				trueNegatives = numberOfTokens 
				- truePositives
				- falsePositives
				- falseNegatives;

				//beware the divide by zero
				if(truePositives + falsePositives != 0) {
					precision = (float) truePositives / (truePositives + falsePositives);
				}
				else {
					precision = 0;
				}
				if(truePositives + falseNegatives != 0) {
					recall = (float) truePositives / (truePositives + falseNegatives);
				}
				else {
					recall = 0;
				}
				if(precision + recall != 0) {
					fScore = precision * recall / (2 * (precision + recall));
				}
				else {
					fScore = 0;
				}

				output.println();
				output.println(tag.getKey());
				output.println(
						" Overall: " + tag.getValue().inTestData
						+ "    true pos: " + truePositives
						+ "    false pos: " + falsePositives
						+ "    true neg: " + trueNegatives 
						+ "    false neg: " + falseNegatives
						+ "    prec: " + precision
						+ "    rec: " + recall
						+ "    f1: " + fScore);
				output.println();
				output.println();
			}
		}

	}

	public void printOverallResults(List<TaggedToken> taggedTokens){
		
		int numberOfTokens = taggedTokens.size();
		int numberOfCorrectTags = 0;
		
		for(TaggedToken token : taggedTokens){
			if(token.correctTag())
				numberOfCorrectTags++;
			
		}
		
		output.println("Tokens: " + numberOfTokens
				+ "   Correct: " + numberOfCorrectTags
				+ " " + ((float) numberOfCorrectTags / ( numberOfTokens)* 100) + "%");
		
		int falseNegatives = 0;
		int falsePositives = 0;
		int truePositives = 0;
		int trueNegatives = 0;
		int inTestData = 0;
		float precision;
		float recall;
		float fScore;
		HashMap<String, TagStats> tagStats = getTagStats(taggedTokens);
		
		for(String tag : getGeneratedTags(taggedTokens)) {
			
			if(!tag.equals("unknown")) {
				TagStats stats = tagStats.get(tag);
				falseNegatives += stats.falseNegatives;
				falsePositives += stats.falsePositives;
				truePositives += stats.truePositives;
				inTestData += stats.inTestData;
			}
		}
		
		for(TaggedToken token : taggedTokens){
			if(token.generatedTag.equals("unknown")) {
				trueNegatives++;
			}
		}
		
		//beware the divide by zero
		if(truePositives + falsePositives != 0) {
			precision = (float) truePositives / (truePositives + falsePositives);
		}
		else {
			precision = 0;
		}
		if(truePositives + falseNegatives != 0) {
			recall = (float) truePositives / (truePositives + falseNegatives);
		}
		else {
			recall = 0;
		}
		if(precision + recall != 0) {
			fScore = precision * recall / (2 * (precision + recall));
		}
		else {
			fScore = 0;
		}
		
		int ambiguousNumber = getAmbiguousWords(taggedTokens).size();
		float ambiguousPercentage;
		
		if(numberOfTokens == 0){
			ambiguousPercentage = 0;
		}
		else {
			ambiguousPercentage =  (float) ambiguousNumber * 100 / (float) numberOfTokens;
		}
		
		output.println();
		output.println("For tags generated by the tagger overall:");
		output.println("true pos: " + truePositives + "  out of a possible " + inTestData);
		output.println("false pos: " + falsePositives);
		output.println("true neg: " + trueNegatives);
		output.println("false neg: " + falseNegatives);
		output.println();
		output.println("Precision: " + precision);
		output.println("Recall: " + recall);
		output.println("F-Score: " + fScore);
		output.println();
		output.println("Ambiguous words in data: " + ambiguousNumber + " of " + numberOfTokens);
		output.println("Ambiguous percentage: " + ambiguousPercentage + "%");
		output.println();
		output.println();
	}
	
	public void printConfusionMatrix(List<TaggedToken> taggedTokens){
		
		HashSet<String> generatedTags = getGeneratedTags(taggedTokens);
		HashSet<String> testDataTags = getTestDataTags(taggedTokens); 
		
		String line = "                         ";
		
		for(String generatedTag : generatedTags){
			line += "     " + generatedTag;
		}
		
		output.println("Confusion Matrix:");
		output.println();
		output.println("each line - same tag in data");
		output.println("each column - same tag from tagger");
		output.println();
		output.println(line);
		
		int longestDataTag = 0;
		
		for(String dataTag : testDataTags){
			if (dataTag.length() > longestDataTag) {
				longestDataTag = dataTag.length();
			}
			
		}
		
		for(String dataTag : testDataTags){
									
			line = forceLength(dataTag, longestDataTag + 5);
			
			for(String generatedTag : generatedTags){
				
				int number = 0;
				
				for(TaggedToken token : taggedTokens){
					if((token.generatedTag.equals(generatedTag))
							&& (token.testDataTag.equals(dataTag))){
						
						number++;
					}
				}
				
				String entry = forceLength("" + number, generatedTag.length() + 5); 
				
				line += entry;
				
			}
			
			output.println(line);
			
		}
		
		
	}
	
	
	public void printAmbiguosWords(List<TaggedToken> taggedTokens){
		
		output.println("Ambiguous words and their tags in test data:");
		
		for(Map.Entry<String, HashSet<String>> word : getAmbiguousWords(taggedTokens).entrySet()){
			
			String tags = "";
			
			for(String tag : word.getValue()){
				tags = tags + tag + "\t";
			}
			
			output.println(word.getKey() + "\t" + tags);
		}
		
		output.println();
		output.println();
	}
	
	
	
	public HashMap<String, HashSet<String>> getAmbiguousWords(List<TaggedToken> taggedTokens){
		
		HashMap<String, HashSet<String>> tagsPerWord = 
			new LinkedHashMap<String, HashSet<String>>();
		
		for(TaggedToken token : taggedTokens){
			
			if(tagsPerWord.containsKey(token.token)){
				
				tagsPerWord.get(token.token).add(token.testDataTag);
				
			}
			else {
				
				HashSet<String> tags = new HashSet<String>();
				tags.add(token.testDataTag);
				
				tagsPerWord.put(token.token, tags);
				
			}
			
		}
		
		HashMap<String, HashSet<String>> ambiguousWords =
			new LinkedHashMap<String, HashSet<String>>();
		
		for(Map.Entry<String, HashSet<String>> word : tagsPerWord.entrySet()) {
			
			if(word.getValue().size() > 1){
				ambiguousWords.put(word.getKey(), word.getValue());
			}
			
		}
		
		return ambiguousWords;
	}
	
	
	
	
	
	private HashMap<String, TagStats> getTagStats(List<TaggedToken> taggedTokens){
		
		HashMap<String, TagStats> tagStats = new LinkedHashMap<String, TagStats>();
		HashSet<String> tags = getAllTags(taggedTokens);
		
		
		for(String tag : tags) {
			
			
			TagStats stats = new TagStats();
			
			for(TaggedToken token : taggedTokens) {
				
				if(token.generatedTag.equals(tag)){
					
					
					if(token.correctTag()) {
						stats.truePositives++;
						stats.inTestData++;
					}
					else {
						stats.falsePositives++;
					}
					
				}
				else if(token.testDataTag.equals(tag)) {
					
					stats.inTestData++;
					
					if(!token.correctTag()) {
						stats.falseNegatives++;
					}

				}
			
			}
			
			stats.trueNegatives = stats.inTestData
									- stats.falseNegatives
									- stats.falsePositives
									- stats.truePositives;
			
			tagStats.put(tag, stats);		
		}
		
		return tagStats;
	}
	
	
	private HashSet<String> getGeneratedTags(List<TaggedToken> taggedTokens){
		HashSet<String> tags = new HashSet<String>();
		
		for(TaggedToken token : taggedTokens){
			tags.add(token.generatedTag);
		}
		
		return tags;
	}
	
	private HashSet<String> getTestDataTags(List<TaggedToken> taggedTokens){
		HashSet<String> tags = new HashSet<String>();
		
		for(TaggedToken token : taggedTokens){
			tags.add(token.testDataTag);
		}
		
		return tags;
	}
	
	private HashSet<String> getAllTags(List<TaggedToken> taggedTokens){
		HashSet<String> tags = new HashSet<String>();
		
		for(TaggedToken token : taggedTokens){
			tags.add(token.generatedTag);
			tags.add(token.testDataTag);
		}
		
		return tags;
	}
	
	private String forceLength(String string, int length){
		
		if(string.length() > length){
			string = string.substring(0, length);
		}
		else {
			
			for(int i = string.length(); i < length; i++ ){
				string += " ";
			}
		}
		
		return string;
	}
	
	
	//TODO confusion matrix, word counts, tag counts, stats per tag, ambiguous words
	// evaluate per rule?
	
	
	
	

}
